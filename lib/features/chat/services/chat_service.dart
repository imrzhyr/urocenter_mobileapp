import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:path/path.dart' as path;
import 'package:logger/logger.dart';
import '../models/message_model.dart';

/// Service for chat features and messages
class ChatService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseStorage _storage = FirebaseStorage.instance;
  final Logger _logger = Logger();

  /// Send a message to Firestore
  Future<void> sendMessageToFirestore(String chatId, Message message) async {
    // Create a chat document first if it doesn't exist (idempotent)
    await _ensureChatExists(chatId, message.senderId, message.recipientId ?? '');
    
    // Remove the temporary ID from the message data if it has one
    final messageData = message.toMap();
    if (messageData.containsKey('id')) {
      messageData.remove('id'); // ID will be auto-generated by Firestore
    }
    
    // Add server timestamp for accurate sorting
    messageData['createdAt'] = FieldValue.serverTimestamp();
    
    // Add the message to the subcollection
    await _firestore
        .collection('chats')
        .doc(chatId)
        .collection('messages')
        .add(messageData);
        
    // Update the chat document with the latest message info
    await _updateChatDocument(chatId, messageData);
  }
  
  /// Get a stream of messages for a specific chat
  Stream<List<Message>> getMessagesStream(String chatId) {
    // Return a stream of messages sorted by timestamp (descending order first, then reversed)
    return _firestore
        .collection('chats')
        .doc(chatId)
        .collection('messages')
        .orderBy('createdAt', descending: true) // Order by most recent first
        .limit(30) // Only load most recent 30 messages initially
        .snapshots()
        .map((snapshot) {
          final List<Message> messages = snapshot.docs.map((doc) {
            final data = doc.data();
            data['id'] = doc.id; // Add document ID to the data
            return Message.fromMap(data);
          }).toList();
          
          // Reverse to get chronological order for display
          return messages.reversed.toList();
        });
  }

  /// Load older messages (for pagination)
  Future<List<Message>> getOlderMessages(String chatId, DateTime beforeTimestamp, int limit) async {
    try {
      final snapshot = await _firestore
          .collection('chats')
          .doc(chatId)
          .collection('messages')
          .orderBy('createdAt', descending: true)
          .where('createdAt', isLessThan: beforeTimestamp)
          .limit(limit)
          .get();
      
      final List<Message> messages = snapshot.docs.map((doc) {
        final data = doc.data();
        data['id'] = doc.id;
        return Message.fromMap(data);
      }).toList();
      
      return messages.reversed.toList();
    } catch (e) {
      _logger.d("Error loading older messages: $e");
      return [];
    }
  }
  
  /// Ensure the chat document exists
  Future<void> _ensureChatExists(String chatId, String senderId, String recipientId) async {
    final docSnapshot = await _firestore.collection('chats').doc(chatId).get();
    
    if (!docSnapshot.exists) {
      // Create the chat document if it doesn't exist
      await _firestore.collection('chats').doc(chatId).set({
        'participants': [senderId, recipientId],
        'createdAt': FieldValue.serverTimestamp(),
        'lastMessage': null,
        'lastMessageTime': null,
        'lastMessageSenderId': null,
        'status': 'active', // Default status for new chats
      });
    }
  }
  
  /// Update the chat document with the latest message info
  Future<void> _updateChatDocument(String chatId, Map<String, dynamic> messageData) async {
    await _firestore.collection('chats').doc(chatId).update({
      'lastMessage': messageData['content'],
      'lastMessageType': messageData['type'],
      'lastMessageTime': FieldValue.serverTimestamp(),
      'lastMessageSenderId': messageData['senderId'],
      // Don't update status here, that's a separate operation
    });
  }

  /// Upload a chat image and return the download URL
  Future<String?> uploadChatImage(String chatId, String localFilePath) async {
    try {
      final File file = File(localFilePath);
      final String fileName = path.basename(localFilePath);
      
      // Create a reference to 'chats/{chatId}/images/{fileName}'
      final storageRef = _storage.ref().child('chats/$chatId/images/$fileName');
      
      // Upload the file
      final uploadTask = storageRef.putFile(file);
      final taskSnapshot = await uploadTask.whenComplete(() {});
      
      // Get the download URL
      final String downloadUrl = await taskSnapshot.ref.getDownloadURL();
      return downloadUrl;
    } catch (e) {
      _logger.d('Error uploading chat image: $e');
      return null;
    }
  }

  /// Upload a chat document and return the download URL
  Future<String?> uploadChatDocument(String chatId, String localFilePath, String? fileName) async {
    try {
      final File file = File(localFilePath);
      final String nameToUse = fileName ?? path.basename(localFilePath);
      
      // Create a reference to 'chats/{chatId}/documents/{fileName}'
      final storageRef = _storage.ref().child('chats/$chatId/documents/$nameToUse');
      
      // Upload the file
      final uploadTask = storageRef.putFile(file);
      final taskSnapshot = await uploadTask.whenComplete(() {});
      
      // Get the download URL
      final String downloadUrl = await taskSnapshot.ref.getDownloadURL();
      return downloadUrl;
    } catch (e) {
      _logger.d('Error uploading chat document: $e');
      return null;
    }
  }

  /// Upload a voice message and return the download URL
  Future<String?> uploadChatVoice(String chatId, String localFilePath) async {
    try {
      final File file = File(localFilePath);
      final String fileName = path.basename(localFilePath);
      
      // Create a reference to 'chats/{chatId}/voice/{fileName}'
      final storageRef = _storage.ref().child('chats/$chatId/voice/$fileName');
      
      // Upload the file
      final uploadTask = storageRef.putFile(file);
      final taskSnapshot = await uploadTask.whenComplete(() {});
      
      // Get the download URL
      final String downloadUrl = await taskSnapshot.ref.getDownloadURL();
      return downloadUrl;
    } catch (e) {
      _logger.d('Error uploading voice message: $e');
      return null;
    }
  }

  /// Start an audio call and create a call document
  Future<String?> startAudioCall({
    required String callerId,
    required String callerName,
    required String calleeId,
    required String calleeName,
  }) async {
    try {
      // First check if there's already an active call between these users
      // This check helps prevent duplicate calls
      final existingCallQuery = await _firestore
          .collection('calls')
          .where('callerId', isEqualTo: callerId)
          .where('calleeId', isEqualTo: calleeId)
          .where('status', whereIn: ['pending', 'ringing', 'answered'])
          .get();
          
      if (existingCallQuery.docs.isNotEmpty) {
        _logger.d("Already have an active call between these users");
        return existingCallQuery.docs.first.id;
      }
      
      // Create a new call document with initial data
      final callDoc = await _firestore.collection('calls').add({
        'callerId': callerId,
        'callerName': callerName,
        'calleeId': calleeId,
        'calleeName': calleeName,
        'status': 'pending',
        'startTime': FieldValue.serverTimestamp(),
        'endTime': null,
        'type': 'audio',
        // WebRTC fields will be added later
        'offer': null,
        'answer': null,
      });
      
      return callDoc.id;
    } catch (e) {
      _logger.d('Error starting audio call: $e');
      return null;
    }
  }

  // Admin-only: Update chat status
  Future<bool> updateChatStatus(String chatId, String status) async {
    try {
      await _firestore.collection('chats').doc(chatId).update({
        'status': status,
        'statusUpdatedAt': FieldValue.serverTimestamp(),
      });
      return true;
    } catch (e) {
      _logger.d('Error updating chat status: $e');
      return false;
    }
  }
  
  // Get a specific chat document
  Future<Map<String, dynamic>?> getChatDocument(String chatId) async {
    try {
      final doc = await _firestore.collection('chats').doc(chatId).get();
      if (doc.exists) {
        return doc.data() as Map<String, dynamic>;
      }
      return null;
    } catch (e) {
      _logger.d('Error getting chat document: $e');
      return null;
    }
  }
} 